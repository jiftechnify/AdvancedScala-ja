# モナド {#sec:monads}

**モナド** は Scala において最もありふれた抽象化手法のひとつである。
多くの Scala プログラマはすぐに、モナドに(その名前を知ることはなくとも)直感的に精通することになる。

形式ばらずにいえば、モナドとはコンストラクタと`flatMap`メソッドを持つすべてである。
`Option`、`List`、`Future`を含む、前章で見たすべてのファンクタはモナドでもある。
さらに、モナドをサポートする特別な構文も用意されている: for 内包表記(for comprehension)だ。
しかし、その概念の普遍性にもかかわらず、Scala 標準ライブラリは「`flatMap`できるもの」を指す具体的な型を欠いている。
この型クラスは Cats によって提供される恩恵のひとつである。

本章ではモナドを深く掘り下げていく。
まずいくつかの例によってその動機を知ることから始める。
そして、モナドの形式的な定義と Cats におけるその実装を見る。
最後に、あなたがまだ見たことがないかもしれないいくつかの興味深いモナドを、その説明と使用例を交えながら見て回ることにする。

## モナドとは何か?

この問いはこれまでに数千のブログ記事で提起され、その度に説明や比喩が付け加えられてきた。その比喩は猫、メキシコの食べ物、有毒なゴミでいっぱいの宇宙服、そして自己関手の圏におけるモノイド対象(それが何を意味するにせよ)など多岐にわたる。
モナドの意味を次のように非常にシンプルに述べることで、モナドの説明という問題を今回きりで解決してしまおう:

> モナドは **逐次的な計算** のための仕組みである。

なんと簡単なことだろうか! これで問題は解決しただろう?
しかし、前章で、ファンクタはまさにこれと同じような制御機構であると説明したではないか。
わかった、もう少し議論を進めることにしよう…

[@sec:functors:examples]節において、ファンクタは何らかの複雑な状態を無視しながら計算を連鎖させることを可能にするものだと説明した。
しかし、ファンクタでは計算列の最初でしか、この複雑な状態を扱うことができない。
ファンクタは、計算の連鎖の各ステップで追加で発生する複雑な状態については何も関知しないのだ。

そこでモナドの登場である。
モナドの`flatMap`メソッドによって、複雑な中間状態を考慮に入れつつ、次に何が起こるかを指定することが可能となる。
`Option`の`flatMap`メソッドは中間状態としての`Option`を考慮に入れる。
`List`の`flatMap`メソッドは中間状態としての `List`を扱う。以下同様だ。
それぞれの場合において、`flatMap`に渡される関数は計算の「アプリケーション特有」の部分を指定し、`flatMap`自身は、その結果に再び`flatMap`を適用できるようにしながら、複雑な状態を扱う。
ここで地に足をつけて、例を見ていくことにしよう。
