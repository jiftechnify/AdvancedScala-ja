## まとめ

ファンクタは「計算の連鎖」という振る舞いを表現する。
本章では3種類のファンクタを見てきた:

- 通常の共変ファンクタである`Functor`。ある文脈の中の値に関数を適用する能力を表す`map`メソッドを持つ。
  `map`を連続で呼び出すことで、複数の関数を **逐次的に** 適用できる。それぞれの関数は、前の関数の結果を引数として受け取る。

- 反変ファンクタ`Contravariant`。関数のような振る舞いをする文脈において、関数を「前に追加する」能力を表す`contramap`メソッドを持つ。
  `contramap`を連続で呼び出すことで、`map`とは逆方向に関数を連鎖させることができる。

- 非変ファンクタ`Invariant`。両方向の変換を表す`imap`メソッドを持つ。

通常の`Functor`はこれらの型クラスの中では群を抜いてありふれているが、それ自体が利用されることは少ない。
ファンクタは、我々がいつも利用している、より興味深い抽象化の基礎的な構成要素である。
次章以降ではこれらの抽象化のうちの2つ、**モナド** と **アプリカティブファンクタ** を見ていく。

コレクションに対するファンクタは、各要素をその他の要素とは独立に変換できるため、非常に重要である。
これにより、巨大なコレクションの変換を並列化したり、分散化したりすることができるようになる。これは[Hadoop][link-hadoop]のような「map-reduce」フレームワークで頻繁に用いられるテクニックである。
このアプローチについては、本書の後半にある[Map-reduce](#map-reduce)の事例でより詳しく見ていく。

`Contravariant`や`Invariant`型クラスは、`Functor`に比べると適用できる範囲が狭い。それでも、変換処理を表現するデータ型を構築するのに役立っている。
[@sec:applicative]章で[`Semigroupal`](#semigroupal)型クラスについて考える際に、これらを再び取り上げる。
